#pragma kernel CSMain

RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

StructuredBuffer<float2> offsets;
float offsetLength;

const float pi = 3.141592653589793238462;

float DegToRad(float deg){
    return deg * pi / 180.0;
}

bool NearZero(float3 v){
    const float s = 1e-8;
    return abs(v.x) < s && abs(v.y) < s && abs(v.z) < s;
}

//https://www.shadertoy.com/view/4djSRW
float HashOld33(float3 p ) {
	p = float3( dot(p,float3(127.1,311.7, 74.7)),
			  dot(p,float3(269.5,183.3,246.1)),
			  dot(p,float3(113.5,271.9,124.6)));

	return frac(sin(p)*43758.5453123);
}

float MinMax(float value, float min, float max) {
    return min + (max - min) * value;
}

float3 Rand3(float3 seed, float min, float max){
    float r1 = HashOld33(seed.xyz);
    float r2 = HashOld33(seed.yxx);
    float r3 = HashOld33(seed.zzx);
    return float3(MinMax(r1, min, max),MinMax(r2, min, max),MinMax(r3, min, max));
}

float3 RandInUnitSphere(float3 seed){
    while(true){
        float3 p = Rand3(seed, -1.0, 1.0);
        if(dot(p,p) >= 1.0) continue;
        return p;
    }
    return float3(0,0,0);
}

float3 RandInHemiSphere(float3 seed, float3 normal){
    float3 inUnitSphere = RandInUnitSphere(seed);
    if(dot(inUnitSphere,normal) > 0.0) return inUnitSphere;
    return -inUnitSphere;
}

struct Ray {
    float3 origin;
    float3 direction;
};

float3 RayAt(Ray ray, float t){
    return ray.origin + ray.direction * t;
}

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

struct Material {
    int type;//0-lambertian;1-metal;2-dielectric
    float4 albedo;//albedo + fuzz(or index of refraction)
};

Material CreateMat(int type, float4 albedo){
    Material mat;
    if(type == 1) albedo.w  = albedo.w < 1 ? albedo.w : 1;
    mat.type = type;
    mat.albedo = albedo;
    return mat;
}

struct HitRecord {
    float3 p;
    float3 normal;
    float t;
    bool frontFace;
    Material mat;
};

void SetFaceNormal(Ray ray, float3 outwardNormal, inout HitRecord hit){
    hit.frontFace = dot(ray.direction, outwardNormal) < 0;
    hit.normal = hit.frontFace ? outwardNormal : -outwardNormal;
}

float Reflectance(float cosine, float refIdx){
    float r0 = (1.0 - refIdx) /  (1.0 + refIdx);
    r0 = r0 * r0;
    return r0 + (1 - r0) * pow(1.0 - cosine, 5.0);
}

float3 Refract (float3 uv, float3 n, float etaiOverEtat){
    float cosTheta = min(dot(-uv,n),1.0);
    float3 rOutPerp = etaiOverEtat * (uv + cosTheta * n);
    float3 rOutParallel = -sqrt(abs(1.0 - dot(rOutPerp,rOutPerp))) * n;
    return rOutPerp + rOutParallel;
}

bool DielectricScatter(Material mat, Ray rayIn, HitRecord hit, inout float3 attenuation, inout Ray rayScattered){
    attenuation = float3(1.0,1.0,1.0);
    float refractionRatio = hit.frontFace ? (1.0 / mat.albedo.w) : mat.albedo.w;

    float3 unitDir = normalize(rayIn.direction);
    float cosTheta = min(dot(-unitDir, hit.normal),1.0);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    bool cannotRefract = refractionRatio * sinTheta > 1.0;
    float3 direction;

    if(cannotRefract || Reflectance(cosTheta, refractionRatio) > HashOld33(rayIn.direction)) direction = reflect(unitDir, hit.normal);
    else direction = Refract(rayIn.direction, hit.normal, refractionRatio);

    rayScattered = CreateRay(hit.p, direction);
    return true; 
}

bool LambertianScatter(Material mat, Ray rayIn, HitRecord hit, inout float3 attenuation, inout Ray rayScattered){
    float3 scatterDirection = hit.normal + RandInUnitSphere(rayIn.direction);
    if(NearZero(scatterDirection)) scatterDirection = hit.normal;
    rayScattered = CreateRay(hit.p, scatterDirection);
    attenuation = mat.albedo;
    return true; 
}

bool MetalScatter(Material mat, Ray rayIn, HitRecord hit, inout float3 attenuation, inout Ray rayScattered){
    float3 reflected = reflect(rayIn.direction, hit.normal);
    float fuzz = mat.albedo.w;
    rayScattered = CreateRay(hit.p, reflected + fuzz * RandInUnitSphere(rayIn.direction));
    attenuation = mat.albedo.rgb;
    return dot(rayScattered.direction, hit.normal) > 0;
}

bool SphereHit(float3 center, float radius, Material mat, Ray ray, float tMin, float tMax, inout HitRecord hit){
    float3 oc = ray.origin - center;
    float a = dot(ray.direction,ray.direction);
    float half_b = dot(oc,ray.direction);
    float c = dot(oc,oc) - radius*radius;

    float discriminant = half_b*half_b - a*c;
    if (discriminant < 0) return false;

    float sqrtd = sqrt(discriminant);

    // Find the nearest root that lies in the acceptable range.
    float root = (-half_b - sqrtd) / a;
    if(root < tMin || root > tMax) {
        root = (-half_b + sqrtd) / a;
        if(root < tMin || root > tMax) return false;
    }
    hit.t = root;
    hit.p = RayAt(ray, hit.t);
    float3 outwardNormal = (hit.p - center) / radius;
    hit.mat = mat;
    SetFaceNormal(ray, outwardNormal, hit);

    return true;
}


float3 RayColor(Ray ray, int depth){
    Material matGround = CreateMat(0, float4(0.8,0.8,0.0,0.0));
    Material matCenter = CreateMat(0, float4(0.1,0.2,0.5,0.0));
    Material matLeft = CreateMat(2, float4(0.0,0.0,0.0,1.5));
    Material matRight = CreateMat(1, float4(0.8,0.6,0.2,0.0));

    float3 col = float3(0,0,0);
    float3 multiplier = float3(1.0,1.0,1.0);

    while(depth > 0){
        HitRecord hit;
        bool hitAnything = false;
        float tMin = 0.001;
        float closestSoFar = 1.#INF;

        if(SphereHit(float3(0,-100.5,-1), 100, matGround, ray, tMin, closestSoFar, hit)){
            hitAnything = true;
            closestSoFar = hit.t;
        }
        if(SphereHit(float3(0,0,-1), 0.5, matCenter, ray, tMin, closestSoFar, hit)){
            hitAnything = true;
            closestSoFar = hit.t;
        }
        if(SphereHit(float3(-1,0,-1), 0.5, matLeft, ray, tMin, closestSoFar, hit)){
            hitAnything = true;
            closestSoFar = hit.t;
        }
        if(SphereHit(float3(-1,0,-1), -0.4, matLeft, ray, tMin, closestSoFar, hit)){
            hitAnything = true;
            closestSoFar = hit.t;
        }
        if(SphereHit(float3(1,0,-1), 0.5, matRight, ray, tMin, closestSoFar, hit)){
            hitAnything = true;
            closestSoFar = hit.t;
        }

        if(hitAnything) {
            Ray scatteredRay;
            float3 attenuation;
            bool isScattered = false;

            if(hit.mat.type==0){
                isScattered = LambertianScatter(hit.mat, ray, hit, attenuation, scatteredRay);
            }
            else if(hit.mat.type==1){
                isScattered = MetalScatter(hit.mat, ray, hit, attenuation, scatteredRay);
            }
            else if(hit.mat.type==2){
                isScattered = DielectricScatter(hit.mat, ray, hit, attenuation, scatteredRay);
            }

            if(isScattered){
                multiplier*=attenuation;
                ray = scatteredRay;
                depth--;
            }
            else {
                depth = 0;
            }

            continue;
        }
    
        float t = 0.5 * (ray.direction.y + 1.0);
        col += multiplier * lerp(float3(1.0,1.0,1.0), float3(0.5,0.7,1.0), t);
        break;
    }
    return col;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    Result.GetDimensions(width, height);

    float3 col = float3(0.0,0.0,0.0);
    for(int i = 0; i < offsetLength;i++){
        float2 uv = float2((id.xy + offsets[i]) / float2(width, height) * 2.0f - 1.0f);
        Ray ray = CreateCameraRay(uv);
        col += RayColor(ray,10);
    }
    col = col / offsetLength;
    Result[id.xy] = float4(col,1.0);
}