#pragma kernel CSMain

RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

StructuredBuffer<float2> offsets;
float offsetLength;

const float pi = 3.141592653589793238462;

float DegToRad(float deg){
    return deg * pi / 180.0;
}

struct Ray {
    float3 origin;
    float3 direction;
};

float3 RayAt(Ray ray, float t){
    return ray.origin + ray.direction * t;
}

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

struct HitRecord {
    float3 p;
    float3 normal;
    float t;
    bool frontFace;
};

void SetFaceNormal(Ray ray, float3 outwardNormal, inout HitRecord hit){
    hit.frontFace = dot(ray.direction, outwardNormal) < 0;
    hit.normal = hit.frontFace ? outwardNormal : -outwardNormal;
}

bool SphereHit(float3 center, float radius, Ray ray, float tMin, float tMax, inout HitRecord hit){
    float3 oc = ray.origin - center;
    float a = dot(ray.direction,ray.direction);
    float half_b = dot(oc,ray.direction);
    float c = dot(oc,oc) - radius*radius;

    float discriminant = half_b*half_b - a*c;
    if (discriminant < 0) return false;

    float sqrtd = sqrt(discriminant);

    // Find the nearest root that lies in the acceptable range.
    float root = (-half_b - sqrtd) / a;
    if(root < tMin || root > tMax) {
        root = (-half_b + sqrtd) / a;
        if(root < tMin || root > tMax) return false;
    }
    hit.t = root;
    hit.p = RayAt(ray, hit.t);
    float3 outwardNormal = (hit.p - center) / radius;
    SetFaceNormal(ray, outwardNormal, hit);

    return true;
}


float4 RayColor(Ray ray){
    HitRecord hit;
    bool hitAnything = false;
    float tMin = 0;
    float closestSoFar = 1.#INF;

    if(SphereHit(float3(0,0,-1), 0.5, ray, tMin, closestSoFar, hit)){
        hitAnything = true;
        closestSoFar = hit.t;
    }
    if(SphereHit(float3(0,-100.5,-1), 100, ray, tMin, closestSoFar, hit)){
        hitAnything = true;
        closestSoFar = hit.t;
    }

    if(hitAnything) {
        return float4(0.5 * (hit.normal + 1.0), 1.0);
    }
    float t = 0.5 * (ray.direction.y + 1.0);
    return lerp(float4(1.0,1.0,1.0,1.0), float4(0.5,0.7,1.0,1.0), t);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    Result.GetDimensions(width, height);

    float4 col = float4(0.0,0.0,0.0,0.0);
    for(int i = 0; i < offsetLength;i++){
        float2 uv = float2((id.xy + offsets[i]) / float2(width, height) * 2.0f - 1.0f);
        Ray ray = CreateCameraRay(uv);
        col += RayColor(ray);
    }
    col = col / offsetLength;
    Result[id.xy] = col;
}